#summary Concurrency

=Branch and Merge Computation Tasks=
The static/global [http://code.google.com/p/aic-util/source/browse/trunk/src/main/java/com/sri/ai/util/concurrent/BranchAndMerge.java Branch and Merge] service is a general purpose utility for simplifying performing concurrent execution of work that can be split into sub-tasks or into smaller pieces recursively (i.e. similar to [http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html JDK 7's Fork/Join] executor service concept but works under JDK 6 and hides the implementation details to a larger degree). The intent is to make calls to the service in your code at appropriate points that can take advantage of concurrency. 

== Basic Example ==
{{{
...
public class AProgram {
    ...
    public static void main(String[] args) {
        // Ensure the service is initialized 
        BranchAndMerge.reset();	

        // Create and execute the tasks
        List<ComputationTask>           tasks  = createComputationTasks(100);
        Result<List<ComputationResult>> result = BranchAndMerge.execute(tasks);

        if (result.failureOccurred()) {
            // Exception handling
            ...
        }
        else {
           List<ComputationResult> results = result.getResult();
        }
    }

    private static List<ComputationTask> createComputationTasks(int numberOfTasksToCreate) {
        // Create the required number of computation tasks here
        ...
    }

    // A Computation Specific result.
    private static class ComputationResult {
        ...
    }

    private static class ComputationTask implements Callable<ComputationResult> {
        ...
        @Override
        public ComputationResult call() {
            // The actual computation occurs here
            ...
        }
    }
}
}}}

== Short Circuiting ==
Support for short-circuiting of computation tasks can be achieved by passing a predicate to the the Branch and Merge service when a set of tasks are to be executed. If the predicate returns true (based on the successful completion of a task), all remaining computation tasks will be cancelled and the results calculated so far returned.

{{{
    ...
    public static void doShortCircuitableComputations() {
        ...
        ShortCircuitOnValue shortCircuitOnTrue = new ShortCircuitOnValue(Boolean.TRUE);
		
        Result<List<Object>> results = BranchAndMerge.execute(tasks, shortCircuitOnTrue);

        if (shortCircuitOnTrue.isShortCircuited()) {
            // handle a short circuited result
            ...
        } else {
            // handle a standard result
            ...
        }
    }

    private static class ShortCircuitOnValue implements Predicate<Object> {
        private boolean    shortCircuited        = false;
        private Expression valueToShortCircuitOn = null;

	public ShortCircuitOnValue(Object valueToShortCircuitOn) {
            this.valueToShortCircuitOn = valueToShortCircuitOn;
	}

        public boolean isShortCircuited() {
            return shortCircuited;
        }

        @Override
        public boolean apply(Object value) {
            if (valueToShortCircuitOn.equals(value)) {
                shortCircuited = true;
            }
            return shortCircuited;
        }
    }
...
}}}

== Configuration ==
The level of concurrency to be used at runtime is [Configuration configurable] (i.e. not at all or based on the machine's capability that you are running on). The options available are:
||Name||Default||Note||
||aic.util.branch.and.merge.threading.enabled|| || false || ||
||aic.util.branch.and.merge.use.number.processors.for.thread.pool.size || true ||  ||
||aic.util.branch.and.merge.delta.number.processors.for.thread.pool.size|| 0 || ||
|| aic.util.branch.and.merge.fixed.thread.pool.size || 10 || The use numver of processors for thread pool size needs to be false for this property to take effect ||
 
